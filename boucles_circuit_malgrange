# supprimer les boucles
import numpy as np

def supprimerboucle(G):
    g=len(G)
    for i in range(g):
        if G[i][i]==1:
            G[i][i]=0
    return G

def pastransitoire(L,M): 
    return (np.sum(L)==0 or np.sum(M)==0)

def circuitgraphe(G):
    g=len(G)
    for i in range(g):
        if pastransitoire(G[i,:], G[:,i]):
            for k in range(g):
                G[i][k],G[k][i]=0,0
                
    return G


def pipeline(G):
    M=supprimerboucle(G)
    return circuitgraphe(M)
#Recherhce de tous les circuits possibles

def findCircuits(adjacency_matrix):
    n = len(adjacency_matrix)
    circuits = []

    def explore(v, path):
        if v in path:
            start = path.index(v)
            circuit = path[start:]
            if len(circuit) > 2:  # Ignore self-loops
                circuits.append(circuit)
            return

        for u in range(n):
            if adjacency_matrix[v][u] == 1:
                explore(u, path + [v])

    for i in range(n):
        explore(i, [])

    return circuits
#Algo de Malgrange 

import numpy as np

def malgrange(matrice):
    m = len(matrice)
    CFC = []
    G = np.transpose(matrice)  # Transposer la matrice pour inverser les arÃªtes

    def dfs(u, visited, stack):
        visited[u] = True
        for v in range(m):
            if not visited[v] and G[u][v] == 1:
                dfs(v, visited, stack)
        stack.append(u)

    def dfs_reverse(u, visited, component):
        visited[u] = True
        component.append(u)
        for v in range(m):
            if not visited[v] and matrice[u][v] == 1:
                dfs_reverse(v, visited, component)

    visited = [False] * m
    stack = []
    for u in range(m):
        if not visited[u]:
            dfs(u, visited, stack)

    visited = [False] * m
    while stack:
        u = stack.pop()
        if not visited[u]:
            component = []
            dfs_reverse(u, visited, component)
            CFC.append(component)

    return CFC
